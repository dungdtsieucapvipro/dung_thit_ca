begin;
-- Products table
create table if not exists public.products (
    id bigint generated by default as identity primary key,
    name text not null,
    price numeric(12, 2) not null default 0,
    original_price numeric(12, 2),
    image text,
    category_id bigint not null references public.categories(id) on delete restrict,
    detail text,
    sizes jsonb,
    colors jsonb,
    is_flash_sale boolean default false,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
-- updated_at trigger (reuse function)
create or replace function public.set_updated_at() returns trigger language plpgsql as $$ begin new.updated_at = now();
return new;
end;
$$;
drop trigger if exists trg_products_updated_at on public.products;
create trigger trg_products_updated_at before
update on public.products for each row execute procedure public.set_updated_at();
-- RLS: deny direct access
alter table public.products enable row level security;
do $$ begin execute 'revoke all on table public.products from public, anon, authenticated';
exception
when others then null;
end $$;
do $$ begin execute 'grant select, insert, update, delete on table public.products to service_role';
exception
when others then null;
end $$;
drop policy if exists "deny_all_select_products" on public.products;
drop policy if exists "deny_all_modify_products" on public.products;
create policy "deny_all_select_products" on public.products for
select using (false);
create policy "deny_all_modify_products" on public.products for all using (false) with check (false);
-- RPC: list/get/flash/upsert
create or replace function public.rpc_list_products(
        p_category_id bigint default null,
        p_search text default null,
        p_offset int default 0,
        p_limit int default 50
    ) returns setof public.products language sql security definer
set search_path = public stable as $$
select *
from public.products
where (
        p_category_id is null
        or category_id = p_category_id
    )
    and (
        p_search is null
        or name ilike '%' || p_search || '%'
    )
order by id asc offset greatest(p_offset, 0)
limit least(p_limit, 200);
$$;
create or replace function public.rpc_get_product(p_id bigint) returns public.products language sql security definer
set search_path = public stable as $$
select *
from public.products
where id = p_id;
$$;
create or replace function public.rpc_list_flash_products(p_limit int default 50) returns setof public.products language sql security definer
set search_path = public stable as $$
select *
from public.products
where is_flash_sale is true
order by updated_at desc,
    id desc
limit least(p_limit, 200);
$$;
create or replace function public.rpc_upsert_product(
        p_name text,
        p_price numeric(12, 2),
        p_category_id bigint,
        p_original_price numeric(12, 2) default null,
        p_image text default null,
        p_detail text default null,
        p_sizes jsonb default null,
        p_colors jsonb default null,
        p_is_flash_sale boolean default null,
        p_id bigint default null
    ) returns public.products language plpgsql security definer
set search_path = public as $$
declare v public.products;
begin if p_id is null then
insert into public.products(
        name,
        price,
        original_price,
        image,
        category_id,
        detail,
        sizes,
        colors,
        is_flash_sale
    )
values (
        p_name,
        p_price,
        p_original_price,
        nullif(p_image, ''),
        p_category_id,
        p_detail,
        p_sizes,
        p_colors,
        coalesce(p_is_flash_sale, false)
    )
returning * into v;
else
update public.products
set name = coalesce(nullif(p_name, ''), name),
    price = coalesce(p_price, price),
    original_price = coalesce(p_original_price, original_price),
    image = coalesce(nullif(p_image, ''), image),
    category_id = coalesce(p_category_id, category_id),
    detail = coalesce(p_detail, detail),
    sizes = coalesce(p_sizes, sizes),
    colors = coalesce(p_colors, colors),
    is_flash_sale = coalesce(p_is_flash_sale, is_flash_sale),
    updated_at = now()
where id = p_id
returning * into v;
end if;
return v;
end;
$$;
-- Grant RPC to anon
do $$ begin execute 'revoke all on function public.rpc_list_products(bigint, text, int, int) from public';
execute 'revoke all on function public.rpc_get_product(bigint) from public';
execute 'revoke all on function public.rpc_list_flash_products(int) from public';
execute 'revoke all on function public.rpc_upsert_product(text, numeric, bigint, numeric, text, text, jsonb, jsonb, boolean, bigint) from public';
exception
when others then null;
end $$;
do $$ begin execute 'grant execute on function public.rpc_list_products(bigint, text, int, int) to anon';
execute 'grant execute on function public.rpc_get_product(bigint) to anon';
execute 'grant execute on function public.rpc_list_flash_products(int) to anon';
execute 'grant execute on function public.rpc_upsert_product(text, numeric, bigint, numeric, text, text, jsonb, jsonb, boolean, bigint) to anon';
exception
when others then null;
end $$;
commit;