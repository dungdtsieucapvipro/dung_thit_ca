begin;
-- Schema guard
create schema if not exists public;
-- ================= TABLES =================
create table if not exists public.orders (
    id bigint generated by default as identity primary key,
    user_id text not null,
    -- Zalo User ID
    status text not null default 'pending' check (status in ('pending', 'shipping', 'completed')),
    payment_status text not null default 'pending' check (
        payment_status in ('pending', 'success', 'failed')
    ),
    delivery_type text not null check (delivery_type in ('shipping', 'pickup')),
    shipping_address jsonb,
    -- when delivery_type = 'shipping'
    station_id bigint,
    -- when delivery_type = 'pickup'
    note text,
    total numeric(12, 2) not null default 0,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
create table if not exists public.order_items (
    order_id bigint not null references public.orders(id) on delete cascade,
    product_id bigint not null references public.products(id),
    name text not null,
    image text,
    price numeric(12, 2) not null,
    quantity int not null check (quantity > 0),
    primary key (order_id, product_id)
);
-- updated_at trigger
create or replace function public.set_updated_at() returns trigger language plpgsql as $$ begin new.updated_at = now();
return new;
end;
$$;
drop trigger if exists trg_orders_updated_at on public.orders;
create trigger trg_orders_updated_at before
update on public.orders for each row execute procedure public.set_updated_at();
-- ================= RLS =================
alter table public.orders enable row level security;
alter table public.order_items enable row level security;
do $$ begin execute 'revoke all on table public.orders from public, anon, authenticated';
execute 'revoke all on table public.order_items from public, anon, authenticated';
exception
when others then null;
end $$;
do $$ begin execute 'grant select, insert, update, delete on table public.orders to service_role';
execute 'grant select, insert, update, delete on table public.order_items to service_role';
exception
when others then null;
end $$;
drop policy if exists "orders_deny_all_select" on public.orders;
drop policy if exists "orders_deny_all_modify" on public.orders;
drop policy if exists "order_items_deny_all_select" on public.order_items;
drop policy if exists "order_items_deny_all_modify" on public.order_items;
create policy "orders_deny_all_select" on public.orders for
select using (false);
create policy "orders_deny_all_modify" on public.orders for all using (false) with check (false);
create policy "order_items_deny_all_select" on public.order_items for
select using (false);
create policy "order_items_deny_all_modify" on public.order_items for all using (false) with check (false);
-- ================= RPCs =================
-- Create order
create or replace function public.rpc_create_order(
        p_user_id text,
        p_items jsonb,
        -- [{"product_id":1, "quantity":2}, ...]
        p_delivery_type text,
        -- 'shipping' | 'pickup'
        p_shipping_address jsonb default null,
        p_station_id bigint default null,
        p_note text default null
    ) returns public.orders language plpgsql security definer
set search_path = public as $$
declare v_order public.orders;
v_total numeric(12, 2) := 0;
v_row jsonb;
v_pid bigint;
v_qty int;
v_prod record;
begin if p_user_id is null
or length(p_user_id) = 0 then raise exception 'user_id is required';
end if;
if p_delivery_type not in ('shipping', 'pickup') then raise exception 'delivery_type must be shipping or pickup';
end if;
if p_delivery_type = 'shipping'
and p_shipping_address is null then raise exception 'shipping_address is required for delivery_type=shipping';
end if;
if p_delivery_type = 'pickup'
and p_station_id is null then raise exception 'station_id is required for delivery_type=pickup';
end if;
if jsonb_typeof(p_items) <> 'array'
or jsonb_array_length(p_items) = 0 then raise exception 'p_items must be a non-empty jsonb array';
end if;
-- compute total
for v_row in
select *
from jsonb_array_elements(p_items) loop v_pid := (v_row->>'product_id')::bigint;
v_qty := coalesce((v_row->>'quantity')::int, 0);
if v_pid is null
or v_qty <= 0 then raise exception 'Invalid product or quantity';
end if;
select id,
    name,
    image,
    price into v_prod
from public.products
where id = v_pid;
if v_prod.id is null then raise exception 'Product % not found',
v_pid;
end if;
v_total := v_total + (coalesce(v_prod.price, 0) * v_qty);
end loop;
insert into public.orders(
        user_id,
        status,
        payment_status,
        delivery_type,
        shipping_address,
        station_id,
        note,
        total
    )
values (
        p_user_id,
        'pending',
        'pending',
        p_delivery_type,
        p_shipping_address,
        p_station_id,
        nullif(p_note, ''),
        coalesce(v_total, 0)
    )
returning * into v_order;
for v_row in
select *
from jsonb_array_elements(p_items) loop v_pid := (v_row->>'product_id')::bigint;
v_qty := coalesce((v_row->>'quantity')::int, 0);
select id,
    name,
    image,
    price into v_prod
from public.products
where id = v_pid;
insert into public.order_items(
        order_id,
        product_id,
        name,
        image,
        price,
        quantity
    )
values (
        v_order.id,
        v_prod.id,
        v_prod.name,
        v_prod.image,
        coalesce(v_prod.price, 0),
        v_qty
    );
end loop;
return v_order;
end;
$$;
-- List orders of a user
create or replace function public.rpc_list_orders(
        p_user_id text,
        p_status text default null
    ) returns setof public.orders language sql security definer
set search_path = public stable as $$
select *
from public.orders
where user_id = p_user_id
    and (
        p_status is null
        or status = p_status
    )
order by created_at desc,
    id desc;
$$;
-- Get order header
create or replace function public.rpc_get_order(p_user_id text, p_order_id bigint) returns public.orders language sql security definer
set search_path = public stable as $$
select *
from public.orders
where id = p_order_id
    and user_id = p_user_id;
$$;
-- List order items
create or replace function public.rpc_list_order_items(p_user_id text, p_order_id bigint) returns setof public.order_items language sql security definer
set search_path = public stable as $$
select i.*
from public.order_items i
    join public.orders o on o.id = i.order_id
where o.id = p_order_id
    and o.user_id = p_user_id
order by i.product_id asc;
$$;
-- Grants for anon client
do $$ begin execute 'revoke all on function public.rpc_create_order(text, jsonb, text, jsonb, bigint, text) from public';
execute 'revoke all on function public.rpc_list_orders(text, text) from public';
execute 'revoke all on function public.rpc_get_order(text, bigint) from public';
execute 'revoke all on function public.rpc_list_order_items(text, bigint) from public';
exception
when others then null;
end $$;
do $$ begin execute 'grant execute on function public.rpc_create_order(text, jsonb, text, jsonb, bigint, text) to anon';
execute 'grant execute on function public.rpc_list_orders(text, text) to anon';
execute 'grant execute on function public.rpc_get_order(text, bigint) to anon';
execute 'grant execute on function public.rpc_list_order_items(text, bigint) to anon';
exception
when others then null;
end $$;
commit;